package mt;

#if js
	#error "don't compile this in js"
#end

import flash.geom.Point;
import flash.Lib;
import mt.Replay.GameIn;

/**
 * Input data needed to start a party
 * (Peut etre envoyé en paramètre loader ou sur requête de mode depuis le menu du jeu.)
 */
typedef GameIn = {
	partyId:Int,
	replay:Null<String>, 	//Dans le cas d'un replay : string contenant le replay
	time:Int,				//temps en millisec (sert uniquement pour les replays)
}

/**
 * various datas about a party,
 * mainly for analytics or cheater detection purposes
 */
typedef PartyData = {
	badReplay:Int, 		//nb of party replays which led to different score/time/...
	
	//time/tmod stuff
	maxDelta:Int,		//max pause time between 2 frames
	startTime:Int,		//client start time in ms (flash.Lib.getTimer())
	startDate:Float,	//client start date in ms (Date.now())
	endTime:Float,		//client end time in ms (flash.Lib.getTimer())
	?sendTime:Float,    //client send-to-server time in ms (flash.Lib.getTimer()), only if retry
	
	renderCount:Int, 		// nombre de frame réellement rendues
	
	?exceptionStack:String,
	?replayExceptions:Array<String>,
}

/**
 * Output of a party generated by the loader
 */
typedef GameOut = {
	replay:String,			//data pour le replay ( touches, events )
	time:Int,				// durée de la partie en millisecondes
	score:Int, 				//score total
	?data:PartyData,		//various datas about party, mostly used for cheater detection/analytics
}

/**
 * Real Arkadeo API
 *
 * Fake one is  /common/api/AKApi.hx
 */
class Replay {
	var clickFlag : Bool;
	var record : flash.utils.ByteArray;
	var events : flash.utils.ByteArray;
	var recordBits : Int;
	var recordCount : Int;
	var pendingEvents : Array<Int>;
	public var eventFrame : Int;		//number of played frames since last event
	
	var inUpdate : Bool;
	var seed : Int;
	
	public var lastGameOut : GameOut; //for devloader : last gameOut sent.
	
	// DATA
	public var gameIn:GameIn;
	public var gameOut:GameOut;
	public var partyData:PartyData; //various cheat/debug datas on the party
	
	public var currentFrame : Int; 		//number of frames executed during party
	public var currentRender : Int; // number of frame rendered during party
	public var realFPS : Int;	//real FPS computed by Play.checkCheating()
	public var perf : Float;
	public var perfCap : Float;
	
	public var debugReplay = '';
	public var isDebugReplay = false;

	var gameFinished : Bool;
	var replayEOF : Bool;
	var fps : Float;
	
	public function new(g:GameIn)
	{
		setGameIn(g);
		initPlay();
	}
	
	function setGameIn(g:GameIn) {
		gameIn = g;
		fps = Lib.current.stage.frameRate;			

		initRecord();

		partyData = {
			badReplay:0,
			maxDelta:0,
			startTime:0,
			startDate:0,
			endTime:0.0,
			renderCount:0,
		};
		
		/* update gameIn with the non-null fields ( allows to update gameIn in multiple times ) */
		for(prop in Reflect.fields(g)) {
			var v = Reflect.field(g, prop);
			if(v != null) {
				Reflect.setField(gameIn, prop, v);
			}
		}
		
		var copy  =
		gameOut = {
			replay:null,
			time:0,
			score:0,
			data: partyData,
		}
		
		if(gameIn.partyId != 0)		seed = gameIn.partyId;
	}
	
	function initPlay() {
		if(gameIn == null) throw "use setGameIn() before init()";
		
		currentFrame = 0;
		currentRender = 0;
		perf = 1.0;
		perfCap = 1.0;
		partyData.startDate = Date.now().getTime();
		partyData.startTime = flash.Lib.getTimer();
		
		mt.flash.Key.enableJSKeys("loader");
		
		debugReplay = '';
		
		/* manages "Mouse out of stage" */
		flash.Lib.current.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) clickFlag = true);
		flash.Lib.current.stage.addEventListener(flash.events.Event.MOUSE_LEAVE, function(_) clickFlag = false);
		flash.Lib.current.addEventListener(flash.events.MouseEvent.MOUSE_UP, function(_) clickFlag = false);
		
		clickFlag = false;
		inUpdate = false;

		gameFinished = false;
		replayEOF = false;
	
		initRecord();
		
		#if dev
		if(flash.Lib.current.loaderInfo.parameters.debugReplay == '1') {
			isDebugReplay = true;
			App.forceLog('DEBUG REPLAY');
		}
		#end
		
		if(isReplay()) {
			setReplay(gameIn.replay);
		}
	}
	
	public function isReplay():Bool {
		return gameIn.replay != null;
	}

	public function terminate(){
		gameOver();
		return makeGameOut();
	}
	
	//rather terminate
	function makeGameOut() {
		if ( !gameFinished ) throw "game should be over ";
		
		gameOut.time 	= Math.round(currentFrame * 1000 / fps);
		fillPartyDatas();
		
		return gameOut;
	}
	
	// manages the gameOut.data field
	function fillPartyDatas() {
		//take party datas from Api
		gameOut.data 				= partyData;
		gameOut.data.renderCount 	= currentRender;
		gameOut.data.endTime 		= flash.Lib.getTimer();
	}
	
	public function initRecord() {
		pendingEvents = [];
		record = new flash.utils.ByteArray();
		events = new flash.utils.ByteArray();
		recordBits = recordCount = eventFrame = 0;
	}
	
	public function gameOver() {
		if( gameFinished )	throw "game is already over!";
		if( replayEOF )		return;
		
		gameFinished = true;
		saveReplay();
	}

	function onReplayEOF() {
		if( gameFinished || replayEOF )
			return;
		#if dev
		throw "replay EOF";
		#end
		replayEOF = true;
	}
	
	public function saveReplay() {
		if( isReplay() )
			return;
		var b = new flash.utils.ByteArray();
		b.writeInt(seed);
		b.writeInt(record.length);
		b.writeBytes(record);
		b.writeBytes(events);
		b.compress();
		gameOut.replay = haxe.Serializer.run(haxe.io.Bytes.ofData(b));
	}
	
	/**
	 * CONTROL RECORD / PLAYER
	 */
	
	 function check() {
		if( !inUpdate ) throw "Can't call outside update()";
	}
	
	// check if a key is down without recording it for replay
	public  function unrecordedIsDown(k:Int):Bool {
		return mt.flash.Key.isDown(k);
	}
	
	public static function unrecordedIsToggled(k:Int):Bool {
		return mt.flash.Key.isToggled(k);
	}
	
	public  function isDown( k : Int, ?k2 : Int, ?k3 : Int ) {
		check();
		var v = false;
		if ( isReplay() ) {
			v = getBit();
		}else {
			v = mt.flash.Key.isDown(k) || mt.flash.Key.isDown(k2) || mt.flash.Key.isDown(k3);
			saveBit(v);
		}
		#if dev
		if(isDebugReplay){
			debugReplay += "ID("+[k,k2,k3].join(",")+")"+v+",";
		}
		#end
		return v;
	}

	public  function isToggled( k : Int, ?k2 : Int, ?k3 : Int ) {
		check();
		var v:Bool ;
		if ( isReplay() ){
			v = getBit();
		}else{
			v = mt.flash.Key.isToggled(k) || mt.flash.Key.isToggled(k2) || mt.flash.Key.isToggled(k3);
			saveBit(v);
		}
		#if dev
		if(isDebugReplay){
			debugReplay += "IT(" + [k, k2, k3].join(",") + ")" + v + ",";
		}
		#end
		return v;
	}
	
	static var tmpPoint = new Point();
	public  function isClicked( ?mc : flash.display.DisplayObject, ?accurate : Bool = false ) {
		check();
		if ( isReplay() )
			return getBit();
		var v = false;
		if( clickFlag ) {
			if(mc == null) {
				v = true;
			} else {
				tmpPoint.x = mc.mouseX;
				tmpPoint.y = mc.mouseY;
				tmpPoint = mc.localToGlobal(tmpPoint);
				v = mc.hitTestPoint(tmpPoint.x, tmpPoint.y, accurate);
			}
		}
		saveBit(v);
		return v;
	}
	
	public  function getCustomValue(k:Int) {
		check();
		flush();
		
		if(k < 0) throw "CustomValue should be positive";
		
		if( isReplay() ) {
			k = readCustomInt(record);
		}else {
			writeCustomInt(record, k);
		}
		
		#if dev
		if(isDebugReplay){
			debugReplay += "CV" + k + ",";
		}
		#end
		return k;
	}

	public  function getSeed() {
		return seed;
	}
	
	// get bit for replay
	 function getBit():Bool {
		// read a new byte if needed
		if( recordCount == 0 ) {
			try{
				recordBits = record.readByte();
			}catch(e:flash.errors.EOFError) {
				onReplayEOF();
				return false;
			}
			recordCount = 8;
		}
		recordCount--;
		var bit = (recordBits >> recordCount) & 1 == 1;
		return bit;
	}
	

	// Save a bit for replay
	 function saveBit(v:Bool) {
		recordBits <<= 1;
		if( v ) recordBits |= 1;
		recordCount++;
		if( recordCount == 8 ) {
			record.writeByte(recordBits);
			recordCount = 0;
			recordBits = 0;
		}
	}
	
	// called before the game update()
	public  function startFrame() {
		#if dev
		if(isDebugReplay)
			debugReplay += "\nF" + currentFrame + ":";
		#end
		inUpdate = true;
	}
	
	public inline function getFrame() return currentFrame;
	
	// called after the game update()
	public  function endFrame( doRender : Bool ) {
		inUpdate = false;
		eventFrame++;
		currentFrame++;
		if( doRender )
			currentRender++;
		flush();
	}
	
	 function flush() {
		if( recordCount > 0 ) {
			if( !isReplay() ) record.writeByte(recordBits << (8 - recordCount));
			recordCount = 0;
			recordBits = 0;
		}
	}
	
	public  function emitEvent( e : Int ) {
		if ( e < 0 ) throw "Event should be positive";
		if ( isReplay() ) return;
		pendingEvents.push(e);
	}
	
	public  function getEvent() : Null<Int> {
		check();
		if( isReplay() ) {
			if( events.bytesAvailable == 0 )
				return null;
			var old = events.position;
			var frame = readCustomInt(events);
			if( frame <= eventFrame ) {
				eventFrame = 0;
				var e = readCustomInt(events);
				#if dev
				if(isDebugReplay) {
					debugReplay += "EV" + e + ",";
				}
				#end
				return e;
			}
			events.position = old;
			return null;
		}
		var e = pendingEvents.shift();
		if( e == null )
			return null;
		writeCustomInt(events, eventFrame);
		writeCustomInt(events, e);
		eventFrame = 0;
		#if dev
		if(isDebugReplay){
			debugReplay += "EV" + e + ",";
		}
		#end
		return e;
	}
	
	 function writeCustomInt( b : flash.utils.ByteArray, e : Int ) {
		if( e < 0x80 ) {
			b.writeByte(e);
			return;
		}
		if ( e < 1 << 14 ) {
			b.writeByte( (e & 0x7F) | 0x80 );
			b.writeByte( e >> 7 );
			return;
		}
		if ( e < 1 << 21 ) {
			b.writeByte( (e & 0x7F) | 0x80 );
			b.writeByte( ((e >> 7) & 0x7F) | 0x80 );
			b.writeByte( e >> 14 );
			return;
		}
		b.writeByte( (e & 0x7F) | 0x80 );
		b.writeByte( ((e >> 7) & 0x7F) | 0x80 );
		b.writeByte( ((e >> 14) & 0x7F) | 0x80 );
		b.writeByte( ((e >> 21) & 0x7F) | 0x80 );
		b.writeByte( e >> 28 );
	}
	
	 function readCustomInt( b : flash.utils.ByteArray ) {
		try {
			var e : Int = b.readUnsignedByte();
			if ( e < 0x80 )
				return e;
			e &= 0x7F;
			var e2 : Int = b.readUnsignedByte();
			if ( e2 < 0x80 )
				return e | (e2 << 7);
			e2 &= 0x7F;
			var e3 : Int = b.readUnsignedByte();
			if ( e3 < 0x80 )
				return e | (e2 << 7) | (e3 << 14);
			e3 &= 0x7F;
			var e4 : Int = b.readUnsignedByte();
			e4 &= 0x7F;
			var e5 : Int = b.readUnsignedByte();
			return e | (e2 << 7) | (e3 << 14) | (e4 << 21) | (e5 << 28);
			
		}catch(e:flash.errors.EOFError) {
			onReplayEOF();
			return 0;
		}
	}
	
	/// Set the player in replay mode
	public  function setReplay(str) {
		initRecord();
		var b : haxe.io.Bytes = haxe.Unserializer.run(str);
		var b = b.getData();
		b.uncompress();
		b.position = 0;
		seed = b.readInt();
		var size = b.readInt();
		if( size > 0 ) b.readBytes(record, 0, size);
		b.readBytes(events, 0, b.bytesAvailable);
	}
	
	public  function getPerf():Float {
		return perf;
	}
	#if dev
	public  function getPerfCap():Float {
		return perfCap;
	}
	#end
	
	public  function getBaseFramerate():Float {
		return flash.Lib.current.stage.frameRate;
	}
	
	public  function getRealFramerate():Float {
		return realFPS;
	}

}
